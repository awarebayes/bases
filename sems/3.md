# 3 sem

SQL -> DML -> SELECT

```sql
SELECT
FROM
WHERE
GROUP BY
HAVING
ORDER BY
```

Having требует group by

|          | Запрос | Запрос на уровне СУБД |
|----------|--------|-----------------------|
|  SELECT  |    1   |           5           |
|   FROM   |    2   |        1 (1.1)        |
|   WHERE  |    3   |        2 (1.2)        |
| GROUP BY |    4   |           3           |
|  HAVING  |    5   |           4           |
| ORDER BY |    6   |           6           |

> order by нет в реляционной модели т.к. множества не сортируют


| id | Имя       | Дата послед. помывки | Дата рождения | Пол |
|----|-----------|----------------------|---------------|-----|
| 1  | Никита    | 20-08-93             | 20-08-93      | М   |
| 2  | Богдан    | 10-10-80             | 10-10-80      | М   |
| 3  | Евстасий  | 18-05-99             | 17-05-98      | М   |
| 4  | Аркадий   | 10-10-2010           | 10-10-2010    | М   |
| 5  | Евросия   | 03-07-2005           | 20-07-95      | Ж   |
| 6  | Проскофья | 31-12-2022           | 19-011-2000   | Ж   |

id, name,  wash_d, birth_d, gender

```sql
SELECT * from my_table;

SELECT 1+1; -- тоже работает
SELECT public.test();
```

В sql все скаляр. Json, массив, пр.

Особенности **select**.

> двойные ковычки - название атрибутов. Одинарные - строка

```sql
SELECT name AS "Погремуха",
            wash_d,
            gender as "Пол"
        from "Бомж" t;
```

t - в данном случае псевдоним для таблицы

## Where

```sql
where <предикат>;
```

### Предикаты

1) сравнения `<, <=, >, >=, =, <>, !=`

Бомжи которые мылись до 2000

```sql
SELECT ...
WHERE wash_d < '2000-01-01'::date

-- аналогично
CONVERT(date, '2000-01-01')
CAST('2000-01-01' AS DATE)

SELECT ...
WHERE wash_d >= '2000-01-01'::date and wash_d <= '2010-01-01'

```

2) `BETWEEN` 

```sql
WHERE wash_id BETWEEN '2000-01-01' and '2010-01-01'
```

3) `IS [NOT] NULL`

```sql
NULL != NULL, NULL+1=NULL, SUM(1, NULL) = 1

COALESCE(wash_d, name, '1') -- берет первый ненулевой аргумент
```

Бомжи которые никогда не мылись

```sql
SELECT ...
WHERE wash_d IS NOT NULL
```

4) `LIKE` 

`%, _`
`%` - строка любой длины
`_` - один символ

```sql
SELECT ...
WHERE NAME LIKE `%й`
```

Паттерны регистро зависимы, если хочется регистро независимые то

```sql
WHERE UPPER(NAME) LIKE ...
```

5) `IN`

```sql
WHERE birth_d in ('20-09-93', ...)

```

**Places:**

| id | Место Обитания          | Бомж |
|----|-------------------------|------|
| 1  | Мусорное Ведро на ...   |      |
| 2  | Лефортовский Туннель №2 |      |
| 3  | Мусорное Ведро на       |      |
| 4  |                         |      |
| 5  |                         |      |
| 6  |                         |      |

Бомжи в помойке
```sql
SELECT ...
WHERE ID IN ("Бомж" from Places where "Место" = "Мусорное ведро")
```

SELECT лучше использовать для маленьких таблиц
Лучше Использовать JOIN

Аттрибуты снаружи должны совпадать по типу и порядку с аттрибутами внутри.

6) EXISTS

Это мем, а не предикат. Лучше переписать на JOIN

```sql
WHERE EXISTS (SELECT "Бомж" from Places
WHERE PLACE = "Мус. Ведро")
```
EXISTS это очко, он выполняется N раз.
Вылезут все строки начальной таблицы.

Запрос который можно запустить внутри - коррелируемый. 
Как заставить внутренний аттрибут обращаться к внешнему?

```sql
WHERE EXISTS (SELECT "БОМЖ" from Places
WHERE PLACE = "Мус. Ведро" where t.id = "Бомж")
```

Бомжи без места жительства по полу

```sql
SELECT gender, count(*), min(birth_d), 345
from "Бомжи"t
group by gender
having count(*) > 3
```

ПЛОХО!!! Это будет по разному обрабатываться с разным приоритетом!!

```sql
SELECT gender, count(*) AS CNT, min(birth_d), 345
from "Бомжи"t
group by gender
having CNT > 3
```

